# -*- coding: utf-8 -*-
"""TDS_Project_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1j0WQV1_t8cCCdIqPnjcQRmTiD3UGq3g9

# **ANALYSIS OF THE ANSWER**
"""

import pandas as pd
from sklearn.linear_model import LinearRegression

# Load the CSV files
users_df = pd.read_csv('users.csv')
repos_df = pd.read_csv('repositories.csv')

# Q1 Find top 5 users by followers
top_5_followers = users_df.nlargest(5, 'followers')[['login', 'followers']]
top_5_followers

# Question 2: 5 earliest registered GitHub users in Sydney
top_5_earliest = users_df.sort_values(by='created_at').head(5)['login'].tolist()
top_5_earliest

#Q3 Find the top 3 most common licenses
top_3_licenses = repos_df['license_name'].value_counts().nlargest(3)
top_3_licenses

#Q4 Find the company with the most developers
top_company = users_df['company'].mode()[0]
top_company

#Q5 Find the most popular programming language
most_popular_language = repos_df['language'].mode()[0]
most_popular_language

#Q6 Second most popular programming language among users who joined after 2020
users_after_2020 = users_df[users_df['created_at'] > '2020-01-01']
repos_after_2020 = repos_df[repos_df['login'].isin(users_after_2020['login'])]
language_counts = repos_after_2020['language'].value_counts()
second_most_popular_language = language_counts.index[1] if len(language_counts) > 1 else None

second_most_popular_language

#Q7 Find the language with the highest average stars per repository
avg_stars_per_language = repos_df.groupby('language')['stargazers_count'].mean().idxmax()
avg_stars_per_language

#Q8 Calculate leader_strength and find the top 5 users
users_df['leader_strength'] = users_df['followers'] / (1 + users_df['following'])
top_5_leader_strength = users_df.nlargest(5, 'leader_strength')['login']
top_5_leader_strength.tolist()

#Q9 Calculate the correlation between followers and public_repos for users in Sydney
correlation = users_df['followers'].corr(users_df['public_repos'])
correlation

# Q10 Using regression to estimate how many additional followers a user gets per additional public repository
X = users_df[['public_repos']].values
y = users_df['followers'].values
model = LinearRegression().fit(X, y)
followers_per_repo = model.coef_[0]
followers_per_repo

# Q11 Correlation between having projects enabled and wikis enabled
projects_wiki_corr = repos_df['has_projects'].astype(int).corr(repos_df['has_wiki'].astype(int))
projects_wiki_corr

# Q12 Average 'following' for hireable users vs non-hireable users
hireable_following_avg = users_df[users_df['hireable'] == True]['following'].mean()
non_hireable_following_avg = users_df[users_df['hireable'] != True]['following'].mean()
following_diff = hireable_following_avg - non_hireable_following_avg
following_diff

# Q13 Impact of bio length on followers
users_df['bio_length'] = users_df['bio'].dropna().str.split().str.len()
bio_followers_corr = users_df[['bio_length', 'followers']].dropna().corr().loc['bio_length', 'followers']
bio_followers_corr

#Q14 Who created the most repositories on weekends (UTC)? List the top 5 users' login in order, comma-separated
repos_df['created_at'] = pd.to_datetime(repos_df['created_at'])
repos_df['weekday'] = repos_df['created_at'].dt.weekday
weekend_repos = repos_df[repos_df['weekday'] >= 5]
weekend_repo_counts = weekend_repos['login'].value_counts().head(5)
top_5_weekend_users = weekend_repo_counts.index.tolist()

top_5_weekend_users

#Q15 Do people who are hireable share their email addresses more often?
hireable_with_email = users_df[(users_df['hireable'] == True) & (users_df['email'].notna())].shape[0]
hireable_total = users_df[users_df['hireable'] == True].shape[0]
fraction_hireable_with_email = hireable_with_email / hireable_total if hireable_total > 0 else 0
non_hireable_with_email = users_df[(users_df['hireable'] != True) & (users_df['email'].notna())].shape[0]
non_hireable_total = users_df[users_df['hireable'] != True].shape[0]
fraction_non_hireable_with_email = non_hireable_with_email / non_hireable_total if non_hireable_total > 0 else 0
email_fraction_difference = fraction_hireable_with_email - fraction_non_hireable_with_email

fraction_hireable_with_email, fraction_non_hireable_with_email, email_fraction_difference

#Q16 Let's assume that the last word in a user's name is their surname
users_with_names = users_df.dropna(subset=['name']).copy()
users_with_names['surname'] = users_with_names['name'].str.strip().str.split().str[-1]
surname_counts = users_with_names['surname'].value_counts()
max_count = surname_counts.max()
most_common_surnames = surname_counts[surname_counts == max_count].index.tolist()
most_common_surnames.sort()
most_common_surnames